# -*- coding: utf-8 -*-
"""Food101_Machine_Learning_EfficientNetB0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17b3HNvhsu_8Ou-Ea1V9c7_yZrvZmrjzd

#IMPORT LIBRARIES

This is the libraries which will be needed or not to use in NutriBalance
"""

import tensorflow_datasets as tfds
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd
from tensorflow.keras import mixed_precision
from tensorflow.keras import layers
from tensorflow.keras.layers.experimental import preprocessing

# This codes are to check the version of libraries
print("The numpy version is " + np.__version__)
print("The tensorflow version is " + tf.__version__)
print("The pandas version is " + pd.__version__)

"""##DATA COLLECTING

We use TensorFlow Dataset Food101
"""

dataset_food101 = tfds.list_builders()
print("food101" in dataset_food101)

#import dataset food101 from Tensorflow Dataset
(train_data, validation_data), ds_info = tfds.load(name="food101",
                                             split=["train","validation"],
                                             shuffle_files=True,
                                             as_supervised=True,
                                             with_info=True)

figure_of_train_data = tfds.show_examples(train_data, ds_info)

figure_of_validation_data = tfds.show_examples(validation_data, ds_info)

#Show features dictionary
ds_info.features

#show food classes
class_names = ds_info.features["label"].names
ten_first_classes =  class_names[:10]
ten_second_classes = class_names[10:20]
ten_third_classes = class_names[20:30]
ten_fourth_classes = class_names[30:40]
ten_fifth_classes = class_names[40:50]
ten_sixth_classes = class_names[50:60]
ten_seventh_classes = class_names[60:70]
ten_eigth_classes = class_names[70:80]
ten_ninth_classes = class_names[80:90]
ten_tenth_classes = class_names[90:100]
last_one_classes = class_names[100]
print(ten_first_classes)
print(ten_second_classes)
print(ten_third_classes)
print(ten_fourth_classes)
print(ten_fifth_classes)
print(ten_sixth_classes)
print(ten_seventh_classes)
print(ten_eigth_classes)
print(ten_ninth_classes)
print(ten_tenth_classes)
print(last_one_classes)

#take 1 sample of train data
train_sample = train_data.take(1)
train_sample

for image, label in train_sample:
  print(f"""
  Image shape: {image.shape}
  Image dtype: {image.dtype}
  Target class: {label}
  Class name: {class_names[label.numpy()]}
  """)

image

tf.reduce_min(image), tf.reduce_max(image)

title = class_names[label.numpy()]

plt.imshow(image)
plt.title(title)
plt.axis('off')

"""#DATA PREPROCESSING AND EXPLORATORY"""

def preprocessing_image(image, label):
  image = tf.image.resize(image, [224, 224])
  return tf.cast(image, tf.float32), label

preprocessed_image = preprocessing_image(image, label)[0]
image_shape = image.shape
image_dtype = image.dtype
preprocessed_image_shape = preprocessed_image.shape
preprocessed_image_dtype = preprocessed_image.dtype
print(f"Image before preprocessing:\n {image[:2]}...,\nShape: {image_shape},\nDatatype: {image_dtype}\n")
print(f"Image after preprocessing:\n {preprocessed_image[:2]}...,\nShape: {preprocessed_image_shape},\nDatatype: {preprocessed_image_dtype}")

title = class_names[label]

plt.imshow(preprocessed_image/255.)
plt.title(title)
plt.axis(True)

buffer_size = 1000
batch_size = 32
autotune = tf.data.AUTOTUNE

train_data = train_data.map(map_func=preprocessing_image, num_parallel_calls=autotune)
train_data = train_data.shuffle(buffer_size=buffer_size).batch(batch_size=batch_size).prefetch(buffer_size=autotune)
validation_data = validation_data.map(map_func=preprocessing_image, num_parallel_calls=autotune)
validation_data = validation_data.shuffle(buffer_size=buffer_size).batch(batch_size=batch_size).prefetch(buffer_size=autotune)

train_data, validation_data

"""#Using Callbacks"""

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy')>0.75 and logs.get('val_accuracy')>0.75):
      print("\nReached more than 83% accuracy so cancelling training!")
      self.model.stop_training = True

checkpoint_path = "efficientNetB4_model_checkpoints" # save weights in .ckpt
model_checkpoint = tf.keras.callbacks.ModelCheckpoint(checkpoint_path,
                                                      monitor="accuracy",
                                                      save_best_only=True,
                                                      save_weights_only=True,
                                                      verbose=1)

"""#DATA MODELLING"""

import tensorflow as tf
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D

def create_efficientnetB0_model(input_shape=(224, 224, 3)):
    # Load the ResNet-50 model pre-trained on ImageNet data
    base_model = EfficientNetB0(include_top=False, input_shape=input_shape)
    base_model_trainable = False
    inputs = layers.Input(shape=input_shape, name="input_layer")
    x = base_model(inputs, training=False)
    x = layers.GlobalAveragePooling2D(name="pooling_layer")(x)
    x = layers.Dense(len(class_names))(x)
    outputs = layers.Activation("softmax", dtype=tf.float32, name="softmax_float32")(x)
    model = tf.keras.Model(inputs, outputs)

    # Compile the model
    model.compile(optimizer='adam',
                  loss='sparse_categorical_crossentropy',
                  metrics=['accuracy'])

    return model

# Create the model
model = create_efficientnetB0_model()

# Display the model summary
model.summary()

callbacks = myCallback()
history_101_food_feature_extraction = model.fit(train_data,
                                                epochs=5,
                                                steps_per_epoch=len(train_data),
                                                validation_data=validation_data,
                                                validation_steps=int(0.15*len(validation_data)),
                                                callbacks=[callbacks,
                                                           model_checkpoint])

evaluation_of_feature_extraction_model = model.evaluate(validation_data)

evaluation_of_feature_extraction_model

for layer in model.layers:
  layer.trainable=True
  print(layer.name, layer.trainable, layer.dtype, layer.dtype_policy)

reduce_learning_rate = tf.keras.callbacks.ReduceLROnPlateau(monitor="val_loss",
                                                 factor=0.2,
                                                 patience=5,
                                                 verbose=1,
                                                 min_lr=1e-7)
model.compile(loss="sparse_categorical_crossentropy",
              optimizer=tf.keras.optimizers.Adam(learning_rate=0.0001),
              metrics=["accuracy"])

history_101_food_fine_tuning = model.fit(train_data,
                                         epochs=10,
                                         steps_per_epoch=len(train_data),
                                         validation_data=validation_data,
                                         validation_steps=int(0.15*len(validation_data)),
                                         callbacks=[model_checkpoint,
                                                    callbacks,
                                                    reduce_learning_rate])

evaluation_of_fine_tuning_model = model.evaluate(validation_data)

evaluation_of_fine_tuning_model

model.save('food101_model.h5')

from google.colab import files
files.download('food101_model.h5')

"""#Citation"""

@inproceedings{bossard14,
  title = {Food-101 -- Mining Discriminative Components with Random Forests},
  author = {Bossard, Lukas and Guillaumin, Matthieu and Van Gool, Luc},
  booktitle = {European Conference on Computer Vision},
  year = {2014}
}